#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <immintrin.h>
#include <ctype.h>
#include <omp.h>

#include "engine.h"


inline uint32_t min(uint32_t a, uint32_t b) {
	return a < b ? a : b;
}

inline uint32_t max(uint32_t a, uint32_t b) {
	return a > b ? a : b;
}

inline uint64_t min(uint64_t a, uint64_t b) {
	return a < b ? a : b;
}

inline uint64_t max(uint64_t a, uint64_t b) {
	return a > b ? a : b;
}

static inline ssize_t rfc4180_getline(char** lineptr, size_t* n, FILE* stream) {
    if (lineptr == nullptr || n == nullptr || stream == nullptr) {
        return -1;
    }

    size_t len = 0;
    int c;
    int in_quotes = 0;

    if (*lineptr == nullptr) {
        *n = 128;
        *lineptr = (char *)malloc(*n);
        if (*lineptr == nullptr) {
            return -1;
        }
    }

    while ((c = fgetc(stream)) != EOF) {
        if (len + 1 >= *n) {
            *n *= 2;
            char *new_lineptr = (char *)realloc(*lineptr, *n);
            if (new_lineptr == nullptr) {
                return -1;
            }
            *lineptr = new_lineptr;
        }

        (*lineptr)[len++] = c;

        if (c == '"') {
            in_quotes = !in_quotes;
        } else if (c == '\n' && !in_quotes) {
            break;
        }
    }

    if (ferror(stream)) {
        return -1;
    }

    if (len == 0 && c == EOF) {
        return -1;
    }

    (*lineptr)[len] = '\0';
    return len;
}

/*
inline void parse_line_v2(
		const char* line,
		std::vector<char>& text,
		std::vector<uint32_t>& suffix_array_mapping,
		uint64_t file_pos,
		uint32_t column_idx
		) {

	uint32_t char_idx = 0;
	uint32_t col_idx  = 0;

	uint32_t line_length = strlen(line);
	// bool first_in_col = true;

	__m128i comma_mask   = _mm_set1_epi8(',');
	__m128i newline_mask = _mm_set1_epi8('\n');
	__m128i quote_mask   = _mm_set1_epi8('"');
	__m128i escape_mask = _mm_set1_epi8('\\');

	__m128i zero = _mm_setzero_si128();

	while (col_idx < column_idx) {
		__m128i line_v = _mm_loadu_si128((__m128i*)(line + char_idx));
		__m128i comma_cmp = _mm_cmpeq_epi8(line_v, comma_mask);
		__m128i newline_cmp = _mm_cmpeq_epi8(line_v, newline_mask);
		__m128i quote_cmp = _mm_cmpeq_epi8(line_v, quote_mask);
		__m128i escape_cmp = _mm_cmpeq_epi8(line_v, escape_mask);

		__m128i comma_masked = _mm_and_si128(comma_cmp, _mm_cmplt_epi8(zero, line_v));
		__m128i newline_masked = _mm_and_si128(newline_cmp, _mm_cmplt_epi8(zero, line_v));
		__m128i quote_masked = _mm_and_si128(quote_cmp, _mm_cmplt_epi8(zero, line_v));
		__m128i escape_masked = _mm_and_si128(escape_cmp, _mm_cmplt_epi8(zero, line_v));

		__m128i mask = _mm_or_si128(
			_mm_or_si128(
				_mm_or_si128(comma_masked, newline_masked),
				quote_masked
			),
			escape_masked
		);

		uint32_t mask_int = _mm_movemask_epi8(mask);
		if (mask_int != 0) {
			uint32_t idx = __builtin_ctz(mask_int);
			char_idx += idx + 1;
			++col_idx;
			// first_in_col = true;
			continue;
		}

		char_idx += 16;
	}

	// first_in_col = true;

	for (; char_idx < line_length;) {
		__m128i line_v      = _mm_loadu_si128((__m128i*)(line + char_idx));
		__m128i comma_cmp   = _mm_cmpeq_epi8(line_v, comma_mask);
		__m128i newline_cmp = _mm_cmpeq_epi8(line_v, newline_mask);
		__m128i quote_cmp   = _mm_cmpeq_epi8(line_v, quote_mask);
		__m128i escape_cmp  = _mm_cmpeq_epi8(line_v, escape_mask);

		__m128i comma_masked   = _mm_and_si128(comma_cmp,   _mm_cmplt_epi8(zero, line_v));
		__m128i newline_masked = _mm_and_si128(newline_cmp, _mm_cmplt_epi8(zero, line_v));
		__m128i quote_masked   = _mm_and_si128(quote_cmp,   _mm_cmplt_epi8(zero, line_v));
		__m128i escape_masked  = _mm_and_si128(escape_cmp,  _mm_cmplt_epi8(zero, line_v));

		__m128i mask = _mm_or_si128(
			_mm_or_si128(
				_mm_or_si128(comma_masked, newline_masked),
				quote_masked
			),
			escape_masked
		);

		uint32_t mask_int = _mm_movemask_epi8(mask);
		if (mask_int != 0) {
			uint32_t idx = __builtin_ctz(mask_int);
			char_idx += idx + 1;
			break;
		}

		__m128i text_v = _mm_and_si128(line_v, _mm_set1_epi8(0xDF));
		__m128i suffix_v = _mm_set1_epi32(file_pos + char_idx);

		_mm_storeu_si128((__m128i*)(text.data() + text.size()), text_v);
		_mm_storeu_si128((__m128i*)(suffix_array_mapping.data() + suffix_array_mapping.size()), suffix_v);

		text.push_back(tolower(line[char_idx]));
		suffix_array_mapping.push_back(file_pos + char_idx);
		++char_idx;

		// first_in_col = false;
	}


	text.push_back('\n');
	suffix_array_mapping.push_back(file_pos + char_idx);
}
*/

inline void parse_line(
		const char* line,
		buffer_bit* is_quoted_bitflag,
		buffer_c* text,
		buffer_u32* suffix_array_mapping,
		uint64_t file_pos,
		uint32_t column_idx
		) {

	uint32_t char_idx = 0;
	uint32_t col_idx  = 0;

	uint32_t line_length = strlen(line);

	uint16_t _search_col_idx = 0;

	// Iterate of line chars until we get to relevant column.
	while (col_idx != column_idx) {
		if (line[char_idx] == '\n') {
			printf("Newline found before end.\n");
			printf("Search col idx: %d\n", column_idx);
			printf("Col idx: %d\n", col_idx);
			printf("Char idx: %d\n", char_idx);
			printf("Line: %s", line);
			exit(1);
		}

		if (line[char_idx] == '"') {
			// Skip to next unescaped quote
			++char_idx;

			while (1) {
				if (line[char_idx] == '"') {
					if (line[char_idx + 1] == '"') {
						char_idx += 2;
						continue;
					} 
					else {
						++char_idx;
						break;
					}
				}
				++char_idx;
			}
		}

		if (line[char_idx] == ',') ++col_idx;
		++char_idx;
	}

	bool quoted_field = (line[char_idx] == '"');


	if (quoted_field) {
		while (true) {
			if (char_idx > 1048576) {
				printf("Error: Column not found.\n");
				std::exit(1);
			}

			if (line[char_idx] == '"' && line[char_idx + 1] == '"') {
				append_buffer_c(text, tolower(line[char_idx]));
				append_buffer_u32(suffix_array_mapping, file_pos + char_idx);
				append_buffer_bit(is_quoted_bitflag, 1);
				char_idx += 2;
				continue;
			}

			if (
					line[char_idx] == '"' 
						&& 
					(
						line[char_idx + 1] == '\n' 
							|| 
						line[char_idx + 1] == ',' 
							|| 
						line[char_idx + 1] == '\0' 
					)
				) {
				++char_idx;
				break;
			}

			append_buffer_c(text, tolower(line[char_idx]));
			append_buffer_u32(suffix_array_mapping, file_pos + char_idx);
			append_buffer_bit(is_quoted_bitflag, 1);
			++char_idx;
		}
	} else {
		while (true) {
			if (char_idx > 1048576) {
				printf("Error: Column not found.\n");
				std::exit(1);
			}

			if (line[char_idx] == '\n' || line[char_idx] == '\0' || line[char_idx] == ',') {
				break;
			}

			append_buffer_c(text, tolower(line[char_idx]));
			append_buffer_u32(suffix_array_mapping, file_pos + char_idx);
			append_buffer_bit(is_quoted_bitflag, 0);
			++char_idx;
		}
	}

	append_buffer_c(text, '\n');
	append_buffer_u32(suffix_array_mapping, file_pos + char_idx);
	append_buffer_bit(is_quoted_bitflag, (uint8_t)quoted_field);
}

void init_buffer_c(buffer_c* buffer, uint32_t buffer_capacity) {
	buffer->buffer_capacity = buffer_capacity;
	buffer->buffer_idx = 0;
	buffer->buffer = (char*)malloc(buffer_capacity);
}

void append_buffer_c(buffer_c* buffer, char c) {
	if (buffer->buffer_idx == buffer->buffer_capacity) {
		buffer->buffer_capacity *= 2;
		buffer->buffer = (char*)realloc(buffer->buffer, buffer->buffer_capacity);
	}

	buffer->buffer[buffer->buffer_idx++] = c;
}

void free_buffer_c(buffer_c* buffer) {
	free(buffer->buffer);
}


void init_buffer_u32(buffer_u32* buffer, uint32_t buffer_capacity) {
	buffer->buffer_capacity = buffer_capacity;
	buffer->buffer_idx = 0;
	buffer->buffer = (uint32_t*)malloc(buffer_capacity * sizeof(uint32_t));
}

void append_buffer_u32(buffer_u32* buffer, uint32_t c) {
	if (buffer->buffer_idx == buffer->buffer_capacity) {
		buffer->buffer_capacity *= 2;
		buffer->buffer = (uint32_t*)realloc(
				buffer->buffer, 
				buffer->buffer_capacity * sizeof(uint32_t)
				);
	}

	buffer->buffer[buffer->buffer_idx++] = c;
}

void free_buffer_u32(buffer_u32* buffer) {
	free(buffer->buffer);
}


void init_buffer_bit(buffer_bit* buffer, uint32_t buffer_capacity) {
	buffer->buffer_capacity = buffer_capacity;
	buffer->buffer_bit_idx = 0;
	buffer->buffer = (uint8_t*)malloc(buffer_capacity);
}

void append_buffer_bit(buffer_bit* buffer, uint8_t c) {
	uint32_t byte_idx = buffer->buffer_bit_idx / 8;
	uint32_t bit_idx  = buffer->buffer_bit_idx % 8;

	if (byte_idx == buffer->buffer_capacity) {
		buffer->buffer_capacity *= 2;
		buffer->buffer = (uint8_t*)realloc(buffer->buffer, buffer->buffer_capacity);
	}

	buffer->buffer[byte_idx] |= c << bit_idx;
	++(buffer->buffer_bit_idx);
}

uint8_t get_buffer_bit(buffer_bit* buffer, uint32_t idx) {
	uint32_t byte_idx = idx / 8;
	uint32_t bit_idx  = idx % 8;

	return (buffer->buffer[byte_idx] >> bit_idx) & 1;
}

void free_buffer_bit(buffer_bit* buffer) {
	free(buffer->buffer);
}


void construct_truncated_suffix_array_from_csv_partitioned(
	const char* csv_file,
	uint32_t column_idx,
	SuffixArray* suffix_array
) {

	const uint32_t TWO_GB = (uint32_t)2 * (uint32_t)1024 * (uint32_t)1024 * (uint32_t)1024;

	// TODO: Adjust for multithreading correctness.
	clock_t start = clock();

	// Read and parse the CSV file.
	FILE* file = fopen(csv_file, "r");
	if (file == NULL) {
		printf("Error: File not found\n");
		exit(1);
	}

	char*    line = NULL;
	uint64_t len = 0;
	ssize_t  read;
	uint64_t file_pos = suffix_array->global_byte_start_idx;
	uint64_t bytes_read = 0;

	uint32_t num_lines_guess = TWO_GB / (suffix_array->max_suffix_length * 8);
	uint32_t num_bytes_guess = num_lines_guess * suffix_array->max_suffix_length;
	fseek(file, suffix_array->global_byte_start_idx, SEEK_SET);

	buffer_c text;
	init_buffer_c(&text, num_bytes_guess);

	buffer_u32 suffix_array_mapping;
	init_buffer_u32(&suffix_array_mapping, num_bytes_guess);

	while (
			((read = rfc4180_getline(&line, &len, file)) != -1)
				&& 
			(bytes_read < TWO_GB)
			) {

		parse_line(
			line,
			suffix_array->is_quoted_bitflag,
			&text,
			&suffix_array_mapping,
			bytes_read,
			column_idx
		);

		bytes_read += read;
		file_pos   += read;
	}

	fclose(file);

	suffix_array->global_byte_end_idx = file_pos;

	clock_t end = clock();
	double elapsed = ((double)end - start) / CLOCKS_PER_SEC;
	printf("Time to read and parse CSV: %f\n", elapsed);
	printf("Mb/s: %f\n", (double)bytes_read / (1024 * 1024) / elapsed);


	suffix_array->n = suffix_array_mapping.buffer_idx;
	suffix_array->suffix_array = (uint32_t*)malloc(suffix_array->n * sizeof(uint32_t));

	construct_truncated_suffix_array(text.buffer, suffix_array);
	free_buffer_c(&text);

	// Remap suffix array indices to original file positions.
	#pragma omp parallel for
	for (uint32_t i = 0; i < suffix_array->n; ++i) {
		suffix_array->suffix_array[i] = suffix_array_mapping.buffer[suffix_array->suffix_array[i]];
	}

	free_buffer_u32(&suffix_array_mapping);
}

static inline int strncmp_128(const char* str1, const char* str2, uint64_t n) {
    // Load the strings into __m128i registers
    __m128i v1 = _mm_loadu_si128((__m128i*)str1);
    __m128i v2 = _mm_loadu_si128((__m128i*)str2);

    // Setup imm8 to specify unsigned bytes and equality comparison
    // _SIDD_UBYTE_OPS: Treats the comparison data as unsigned bytes.
    // _SIDD_CMP_EQUAL_EACH: Compares each pair of data, looking for equality.
    // _SIDD_BIT_MASK: The result is a bit mask of the comparison results.
	// _SIDD_NEGATIVE_POLARITY: The comparison is negated.
	constexpr const uint8_t mode =
            _SIDD_UBYTE_OPS |
            _SIDD_CMP_EQUAL_EACH |
            _SIDD_NEGATIVE_POLARITY |
            _SIDD_LEAST_SIGNIFICANT;


	const int idx = _mm_cmpistri(v1, v2, mode);
	return ((uint8_t)str1[idx] - (uint8_t)str2[idx]) * ((uint64_t)idx < n);
}

static inline int strncmp_256(const char* str1, const char* str2, uint64_t n) {
    // Load the strings into __m256i registers
	__m256i v1 = _mm256_loadu_si256((__m256i*)str1);
	__m256i v2 = _mm256_loadu_si256((__m256i*)str2);

	// Do a bytewise comp
	__m256i cmp = _mm256_cmpeq_epi8(v1, v2);
	int mask = ~_mm256_movemask_epi8(cmp);

	if (mask == 0) {
		return 0;
	}
	const int idx = __builtin_ctz(mask);

	return ((uint8_t)str1[idx] - (uint8_t)str2[idx]) * ((uint64_t)idx < n);
}

void recursive_bucket_sort(
	const char* str,
	uint32_t* suffix_array,
	uint32_t* temp_suffix_array,
	int string_length,
	uint64_t n,
	int max_depth,
	int current_depth
) {
	// Base case
	if (current_depth == max_depth) {
		return;
	}

	if (n < 32) {
		// Do insertion sort
		for (uint64_t i = 1; i < n; ++i) {
			int j = i;
			// while (j > 0 && strncmp(str + suffix_array[j] + current_depth, str + suffix_array[j - 1] + current_depth, max_depth) < 0) {
			while (j > 0 && strncmp_128(str + suffix_array[j] + current_depth, str + suffix_array[j - 1] + current_depth, max_depth) < 0) {
				std::swap(suffix_array[j], suffix_array[j - 1]);
				--j;
			}
		}
		return;
	}

	// Do bucket sort of first char. Then in each bucket, skip
	// current_depth chars and do bucket sort of next char.

	constexpr int NUM_BUCKETS 	   		 = 256;
	uint32_t _buckets[NUM_BUCKETS] 	     = {0};
	uint32_t _bucket_starts[NUM_BUCKETS] = {0};

	for (uint64_t i = 0; i < n; ++i) {
		int char_idx = suffix_array[i] + current_depth;
		uint8_t char_val = (uint8_t)str[char_idx];
		++_buckets[char_val];
	}

	uint64_t offset = 0;
	for (size_t i = 0; i < NUM_BUCKETS; ++i) {
		_bucket_starts[i] = offset;
		offset += _buckets[i];
	}

	memcpy(temp_suffix_array, suffix_array, n * sizeof(uint32_t));

	for (uint64_t i = 0; i < n; ++i) {
		int char_idx = suffix_array[i] + current_depth;
		uint8_t char_val = (uint8_t)str[char_idx];
		temp_suffix_array[_bucket_starts[char_val]] = suffix_array[i];
		++_bucket_starts[char_val];
	}

	memcpy(suffix_array, temp_suffix_array, n * sizeof(uint32_t));

	// Recalculate bucket starts
	offset = 0;
	for (size_t i = 0; i < NUM_BUCKETS; ++i) {
		_bucket_starts[i] = offset;
		offset += _buckets[i];
	}

	// Recursively sort each bucket
	if (current_depth == 0) {
		#pragma omp parallel for schedule(guided)
		for (int i = 0; i < 255; ++i) {
			int bucket_start = _bucket_starts[i];
			int bucket_end   = _bucket_starts[i + 1];
			if (bucket_end - bucket_start <= 1) {
				continue;
			}

			recursive_bucket_sort(
				str,
				suffix_array + bucket_start,
				temp_suffix_array + bucket_start,
				string_length,
				bucket_end - bucket_start,
				max_depth,
				current_depth + 1
			);
		}
		return;
	}

	for (int i = 0; i < 255; ++i) {
		int bucket_start = _bucket_starts[i];
		int bucket_end   = _bucket_starts[i + 1];
		if (bucket_end - bucket_start <= 1) {
			continue;
		}

		recursive_bucket_sort(
			str,
			suffix_array + bucket_start,
			temp_suffix_array + bucket_start,
			string_length,
			bucket_end - bucket_start,
			max_depth,
			current_depth + 1
		);
	}
}

void read_text_into_buffer(
	const char* filename,
	char** buffer,
	uint64_t* buffer_size
) {
	FILE* file = fopen(filename, "r");
	if (file == NULL) {
		printf("Error: File not found\n");
		exit(1);
	}

	fseek(file, 0, SEEK_END);
	*buffer_size = ftell(file);
	rewind(file);

	printf("File size: %lu MB\n", *buffer_size / (1024 * 1024));

	*buffer = (char*)malloc(*buffer_size);

	fread(*buffer, 1, *buffer_size, file);
	fclose(file);
}

void construct_truncated_suffix_array(const char* str, SuffixArray* suffix_array) {
	clock_t start = clock();

	uint32_t _max_suffix_length = std::min(suffix_array->max_suffix_length, suffix_array->n);
	alignas(64) uint32_t* temp_suffix_array = (uint32_t*)malloc(suffix_array->n * sizeof(uint32_t));

	// Construct simple suffix array from str
	#pragma omp parallel for
	for (uint64_t i = 0; i < suffix_array->n; ++i) {
		suffix_array->suffix_array[i] = i;
	}

	recursive_bucket_sort(
		str,
		suffix_array->suffix_array,
		temp_suffix_array,
		suffix_array->n,
		suffix_array->n,
		suffix_array->max_suffix_length,
		0
	);

	free(temp_suffix_array);

	clock_t end = clock();
	double elapsed = ((double)end - start) / CLOCKS_PER_SEC;
	printf("Time to construct suffix array: %f\n", elapsed);
}


pair_u32 get_substring_positions(
    const char* str,
    const SuffixArray* suffix_array,
    const char* substring
) {
    int64_t m 	  = strlen(substring);
    int64_t first = 0;
    int64_t last  = suffix_array->n - 1;

    int64_t start = -1;
	int64_t end   = -1;

	int64_t cmp_length = min(m, suffix_array->max_suffix_length);

    // Binary search for the first occurrence of the substring
    while (first <= last) {
        int64_t mid = (first + last) / 2;
        if (strncmp(str + suffix_array->suffix_array[mid], substring, cmp_length) < 0) {
        // if (strncmp_128(str + suffix_array[mid], substring, cmp_length) < 0) {
            first = mid + 1;
        }
        else {
            last = mid - 1;
            start = mid;
        }
    }

    if (start == -1) {
        return {UINT32_MAX, UINT32_MAX};
    }

    // Reset for searching the last occurrence
    first = 0;
	last  = suffix_array->n - 1;
    while (first <= last) {
        int64_t mid = (first + last) / 2;
        if (strncmp(str + suffix_array->suffix_array[mid], substring, cmp_length) > 0) {
        // if (strncmp_128(str + suffix_array[mid], substring, cmp_length) > 0) {
            last = mid - 1;
        }
        else {
            first = mid + 1;
            end = mid;
        }
    }

	return {(uint32_t)start, (uint32_t)end};
}

pair_u32 get_substring_positions_file(
	FILE* file,
	const SuffixArray* suffix_array,
    const char* substring
) {
    uint32_t m 	   = strlen(substring);
    uint32_t first = 0;
    uint32_t last  = suffix_array->n - 1;

    uint32_t start = UINT32_MAX;
	uint32_t end   = UINT32_MAX;

	uint32_t cmp_length = min(m, suffix_array->max_suffix_length);

	char* line = (char*)malloc(cmp_length * sizeof(char));

    // Binary search for the first occurrence of the substring
    while (first <= last) {
        uint32_t mid = (first + last) / 2;
		fseek(
				file,
				suffix_array->global_byte_start_idx + (uint64_t)suffix_array->suffix_array[mid],
				SEEK_SET
				);
		fread(line, 1, cmp_length, file);

		for (uint32_t i = 0; i < cmp_length; ++i) {
			line[i] = tolower(line[i]);
		}

        if (strncmp(line, substring, cmp_length) < 0) {
        // if (strncmp_128(line, substring, cmp_length) < 0) {
            first = mid + 1;
        }
        else {
            last  = mid - 1;
            start = mid;
        }
    }

    if (start == UINT32_MAX) {
        return {UINT32_MAX, UINT32_MAX};
    }

    // Reset for searching the last occurrence
    first = 0;
	last  = suffix_array->n - 1;
    while (first <= last) {
        uint32_t mid = (first + last) / 2;
		fseek(
				file,
				suffix_array->global_byte_start_idx + (uint64_t)suffix_array->suffix_array[mid],
				SEEK_SET
				);
		fread(line, 1, cmp_length, file);

		for (uint32_t i = 0; i < cmp_length; ++i) {
			line[i] = tolower(line[i]);
		}

        if (strncmp(line, substring, cmp_length) > 0) {
        // if (strncmp_128(line, substring, cmp_length) > 0) {
            last = mid - 1;
        }
        else {
            first = mid + 1;
            end   = mid;
        }
    }

	return {start, end};
}


char** get_matching_records(
	const char* str,
	SuffixArray* suffix_array,
	const char* substring,
	uint32_t k 
) {
	pair_u32 match_idxs = get_substring_positions(
			str, 
			suffix_array, 
			substring
			);

	if (match_idxs.first == UINT32_MAX) {
		return nullptr;
	}

	uint32_t num_matches = min(k, match_idxs.second - match_idxs.first + 1);

	char** matches = (char**)malloc(num_matches * sizeof(char*));

	for (uint32_t i = match_idxs.first; i < match_idxs.first + num_matches; ++i) {
		// Go to the original index and iterate backwards until newline.
		uint32_t offset = suffix_array->suffix_array[i];
		while (str[offset] != '\n') --offset;
		++offset;

		uint32_t match_length = 0;
		while (true) {
			char c = str[offset++];
			if (c == '\\') {
				++offset;
				match_length += 2;
				continue;
			}
			if (c == '\n') {
				break;
			}
			++match_length;
		}

		char* record = (char*)malloc(match_length + 1);
		memcpy(record, str + offset, match_length);

		matches[i - match_idxs.first] = record;
	}

	return matches;
}

char** get_matching_records_file(
	const char* filename,
	const SuffixArray* suffix_array,
	const char* substring,
	int k 
) {
	FILE* file = fopen(filename, "r");
	if (file == NULL) {
		printf("Error: File not found\n");
		exit(1);
	}

	pair_u32 match_idxs = get_substring_positions_file(
			file,
			suffix_array,
			substring
			);

	if (match_idxs.first == UINT32_MAX) {
		return nullptr;
	}

	size_t num_matches = std::min((size_t)k, (size_t)(match_idxs.second - match_idxs.first + 1));

	char** records = (char**)malloc(num_matches * sizeof(char*));

	char line[1024];

	for (uint32_t i = match_idxs.first; i < match_idxs.first + num_matches; ++i) {
		uint8_t is_quoted = get_buffer_bit(suffix_array->is_quoted_bitflag, i);

		uint64_t byte_offset = (uint64_t)suffix_array->suffix_array[i] + suffix_array->global_byte_start_idx;

		// Go to the original index and iterate backwards until newline.
		uint32_t newline_pos = 0;

		fseek(file, max(byte_offset - 512, 0), SEEK_SET);
		fread(line, 1, 1024, file);

		for (uint32_t j = 0; j < 512; ++j) {
			if (line[j] == '\\') {
				j += 2;
				continue;
			}
			if (line[j] == '\n') {
				newline_pos = j;
			}
		}
		byte_offset = byte_offset - 512 + newline_pos + 1;

		fseek(file, byte_offset, SEEK_SET);
		fread(line, 1, 1024, file);

		uint32_t char_idx = 0;
		while (true) {
			char c = line[char_idx++];
			if (c == '\n') {
				break;
			}
		}
		char* record = (char*)malloc(char_idx + 1);
		memcpy(record, line, char_idx);

		records[i - match_idxs.first] = record;
	}
	fclose(file);

	return records;
}
